const e=(e,s,t)=>Math.min(Math.max(e,s),t),s=(s,[t=1,n=100,a=10,r=0]=[],i)=>{t=e(t,.1,1e3),n=e(n,.1,1e3),a=e(a,.1,1e3),r=e(r,.1,1e3);const o=Math.sqrt(n/t),g=a/(2*Math.sqrt(n*t)),p=g<1?o*Math.sqrt(1-g*g):0,m=g<1?(g*o-r)/p:-r+o;let l=i?i*s/1e3:s;return l=g<1?Math.exp(-l*g*o)*(1*Math.cos(p*l)+m*Math.sin(p*l)):(1+m*l)*Math.exp(-l*o),0===s||1===s?s:1-l},t=new Map,n=1e5,a=([e,a,r,i]=[])=>{let o=[e,a,r,i],g=`${o}`;if(t.has(g))return t.get(g);const p=1/6;let m=0,l=0,u=0;for(;++u<n;)if(m+=p,1===s(m,o,null)){if(l++,l>=16)break}else l=0;const f=m*p*1e3;return t.set(g,f),f},r=e=>(s,t=[],n)=>1-e(1-s,t,n),i=e=>(s,t=[],n)=>s<.5?e(2*s,t,n)/2:1-e(-2*s+2,t,n)/2,o=e=>(s,t=[],n)=>s<.5?(1-e(1-2*s,t,n))/2:(e(2*s-1,t,n)+1)/2,g=s,p=r(s),m=i(s),l=o(s),u=(e,s,t)=>s+(t-s)*e,f=(e,s)=>Math.round(e*10**s)/10**s,h=(s,t,n=3)=>{let a=t.length-1,r=e(Math.floor(s*a),0,a-1),i=t[r],o=t[r+1];return f(u((s-r/a)*a,i,o),n)},c={spring:s,"spring-in":g,"spring-out":p,"spring-in-out":m,"spring-out-in":l},y=e=>{const s=/(\(|\s)([^)]+)\)?/.exec(e.toString());return s?s[2].split(",").map((e=>{let s=parseFloat(e);return Number.isNaN(s)?e.trim():s})):[]},d=(e={})=>{let t="string"==typeof e||Array.isArray(e)&&"function"==typeof e[0],{easing:n=[s,1,100,10,0],numPoints:a=100,decimal:r=3}=t?{easing:e}:e;if("string"==typeof n){let e=c[n.replace(/(\(|\s).+/,"").toLowerCase().trim()];n=[e,...y(n)]}return{easing:n,numPoints:a,decimal:r}},M=new Map,w=(e={})=>{let{easing:s,numPoints:t}=d(e);if(!Array.isArray(s))throw new Error(`[spring-easing] The easing needs to be in the format:  \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity], the easing recieved is "${s}", [spring-easing] doesn't really know what to do with that.`);if("function"!=typeof s[0])throw new Error("[spring-easing] A frame function is required as the first element in the easing array, e.g. [SpringFrame, ...]");s.length>1&&s.length<5&&console.warn(`[spring-easing] Be careful of only setting some of the spring parameters, you've only set ${5-s.length} spring parameter(s). The easing works best in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`),s.length>5&&console.warn(`[spring-easing] You entered ${5-s.length} more spring parameter(s) than necessary. The easing needs to be in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`);let[n,...r]=s;const i=`${r},${t}`;if(M.has(i)){let e=M.get(i);if(e.has(n))return e.get(n)}const o=[];let g=a(r);for(let e=0;e<t;e++)o[e]=n(e/(t-1),r,g);let p=M.has(i)?M.get(i):new WeakMap;return p.set(n,[o,g]),M.set(i,p),[o,g]},F=(e,s={})=>{let t=d(s),[n,a]=w(t);return[n.map((s=>h(s,e,t.decimal))),a]};export{i as EaseInOut,r as EaseOut,o as EaseOutIn,t as EasingDurationCache,c as EasingFunctions,d as EasingOptions,M as FramePtsCache,w as GenerateSpringFrames,n as INTINITE_LOOP_LIMIT,F as SpringEasing,s as SpringFrame,g as SpringInFrame,m as SpringInOutFrame,p as SpringOutFrame,l as SpringOutInFrame,F as default,a as getSpringDuration,h as interpolateNumber,e as limit,y as parseEasingParameters,u as scale,f as toFixed};
