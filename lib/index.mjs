const e=(e,t,n)=>Math.min(Math.max(e,t),n),t=(t,[n=1,s=100,r=10,a=0]=[],i)=>{if(0===t||1===t)return t;n=e(n,.1,1e3),s=e(s,.1,1e3),r=e(r,.1,1e3),a=e(a,.1,1e3);const o=Math.sqrt(s/n),g=r/(2*Math.sqrt(s*n)),p=g<1?o*Math.sqrt(1-g*g):0,l=g<1?(g*o-a)/p:-a+o;let m=i?i*t/1e3:t;return m=g<1?Math.exp(-m*g*o)*(1*Math.cos(p*m)+l*Math.sin(p*m)):(1+l*m)*Math.exp(-m*o),1-m},n=new Map,s=1e5,r=([e,r,a,i]=[])=>{let o=[e,r,a,i],g=`${o}`;if(n.has(g))return n.get(g);const p=1/6;let l=0,m=0,u=0;for(;++u<s;)if(l+=p,1===t(l,o,null)){if(m++,m>=16)break}else m=0;const f=l*p*1e3;return n.set(g,f),f},a=e=>(t,n=[],s)=>1-e(1-t,n,s),i=e=>(t,n=[],s)=>t<.5?e(2*t,n,s)/2:1-e(-2*t+2,n,s)/2,o=e=>(t,n=[],s)=>t<.5?(1-e(1-2*t,n,s))/2:(e(2*t-1,n,s)+1)/2,g=t,p=a(t),l=i(t),m=o(t),u=(e,t,n)=>t+(n-t)*e,f=(e,t)=>Math.round(e*10**t)/10**t,h=(t,n,s=3)=>{let r=n.length-1,a=e(Math.floor(t*r),0,r-1),i=n[a],o=n[a+1];return f(u((t-a/r)*r,i,o),s)},c=e=>{let t=parseFloat(e);return"number"==typeof t&&!Number.isNaN(t)},y=(t,n)=>{t=e(t,0,1);let s=n.length-1;return n[Math.round(t*s)]},d=e=>{let t=parseFloat(e);return e.toString().replace(t.toString(),"")},F=(e,t,n=3)=>{let s="";return c(t[0])&&(s=d(t[0])),h(e,t.map((e=>"number"==typeof e?e:parseFloat(e))),n)+s},M=(e,t,n=3)=>t.every((e=>"number"==typeof e))?h(e,t,n):t.every((e=>c(e)))?F(e,t,n):y(e,t),S={spring:t,"spring-in":g,"spring-out":p,"spring-in-out":l,"spring-out-in":m},w=e=>{const t=/(\(|\s)([^)]+)\)?/.exec(e.toString());return t?t[2].split(",").map((e=>{let t=parseFloat(e);return Number.isNaN(t)?e.trim():t})):[]},O=(e={})=>{let n="string"==typeof e||Array.isArray(e)&&"function"==typeof e[0],{easing:s=[t,1,100,10,0],numPoints:r=100,decimal:a=3}=n?{easing:e}:e;if("string"==typeof s){let e=S[s.replace(/(\(|\s).+/,"").toLowerCase().trim()];s=[e,...w(s)]}return{easing:s,numPoints:r,decimal:a}},b=new Map,E=(e={})=>{let{easing:t,numPoints:n}=O(e);if(!Array.isArray(t))throw new Error(`[spring-easing] The easing needs to be in the format:  \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity], the easing recieved is "${t}", [spring-easing] doesn't really know what to do with that.`);if("function"!=typeof t[0])throw new Error("[spring-easing] A frame function is required as the first element in the easing array, e.g. [SpringFrame, ...]");t.length>1&&t.length<5&&console.warn(`[spring-easing] Be careful of only setting some of the spring parameters, you've only set ${5-t.length} spring parameter(s). The easing works best in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`),t.length>5&&console.warn(`[spring-easing] You entered ${5-t.length} more spring parameter(s) than necessary. The easing needs to be in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`);let[s,...a]=t;const i=`${a},${n}`;if(b.has(i)){let e=b.get(i);if(e.has(s))return e.get(s)}const o=[];let g=r(a);for(let e=0;e<n;e++)o[e]=s(e/(n-1),a,g);let p=b.has(i)?b.get(i):new WeakMap;return p.set(s,[o,g]),b.set(i,p),[o,g]},I=(e,t={},n=M)=>{let s=O(t),[r,a]=E(s);return[r.map((t=>n(t,e,s.decimal))),a]};export{i as EaseInOut,a as EaseOut,o as EaseOutIn,n as EasingDurationCache,S as EasingFunctions,O as EasingOptions,b as FramePtsCache,E as GenerateSpringFrames,s as INFINITE_LOOP_LIMIT,I as SpringEasing,t as SpringFrame,g as SpringInFrame,l as SpringInOutFrame,p as SpringOutFrame,m as SpringOutInFrame,I as default,r as getSpringDuration,d as getUnit,M as interpolateComplex,h as interpolateNumber,F as interpolateString,y as interpolateUsingIndex,c as isNumberLike,e as limit,w as parseEasingParameters,u as scale,f as toFixed};
