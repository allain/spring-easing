"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=(e,t,r)=>Math.min(Math.max(e,t),r),t=(t,[r=1,n=100,s=10,i=0]=[],a)=>{if(0===t||1===t)return t;r=e(r,.1,1e3),n=e(n,.1,1e3),s=e(s,.1,1e3),i=e(i,.1,1e3);const o=Math.sqrt(n/r),p=s/(2*Math.sqrt(n*r)),g=p<1?o*Math.sqrt(1-p*p):0,l=p<1?(p*o-i)/g:-i+o;let u=a?a*t/1e3:t;return u=p<1?Math.exp(-u*p*o)*(1*Math.cos(g*u)+l*Math.sin(g*u)):(1+l*u)*Math.exp(-u*o),1-u},r=new Map,n=1e5,s=([e,s,i,a]=[])=>{let o=[e,s,i,a],p=`${o}`;if(r.has(p))return r.get(p);const g=1/6;let l=0,u=0,m=0;for(;++m<n;)if(l+=g,1===t(l,o,null)){if(u++,u>=16)break}else u=0;const f=l*g*1e3;return r.set(p,f),f},i=e=>(t,r=[],n)=>1-e(1-t,r,n),a=e=>(t,r=[],n)=>t<.5?e(2*t,r,n)/2:1-e(-2*t+2,r,n)/2,o=e=>(t,r=[],n)=>t<.5?(1-e(1-2*t,r,n))/2:(e(2*t-1,r,n)+1)/2,p=t,g=i(t),l=a(t),u=o(t),m=(e,t,r)=>t+(r-t)*e,f=(e,t)=>Math.round(e*10**t)/10**t,h=(t,r,n=3)=>{let s=r.length-1,i=e(Math.floor(t*s),0,s-1),a=r[i],o=r[i+1];return f(m((t-i/s)*s,a,o),n)},x=e=>{let t=parseFloat(e);return"number"==typeof t&&!Number.isNaN(t)},c=(t,r)=>{t=e(t,0,1);let n=r.length-1;return r[Math.round(t*n)]},y=e=>{let t=parseFloat(e);return e.toString().replace(t.toString(),"")},d=(e,t,r=3)=>{let n="";return x(t[0])&&(n=y(t[0])),h(e,t.map((e=>"number"==typeof e?e:parseFloat(e))),r)+n},F=(e,t,r=3)=>t.every((e=>"number"==typeof e))?h(e,t,r):t.every((e=>x(e)))?d(e,t,r):c(e,t),M={spring:t,"spring-in":p,"spring-out":g,"spring-in-out":l,"spring-out-in":u},S=e=>{const t=/(\(|\s)([^)]+)\)?/.exec(e.toString());return t?t[2].split(",").map((e=>{let t=parseFloat(e);return Number.isNaN(t)?e.trim():t})):[]},w=(e={})=>{let r="string"==typeof e||Array.isArray(e)&&"function"==typeof e[0],{easing:n=[t,1,100,10,0],numPoints:s=100,decimal:i=3}=r?{easing:e}:e;if("string"==typeof n){let e=M[n.replace(/(\(|\s).+/,"").toLowerCase().trim()];n=[e,...S(n)]}return{easing:n,numPoints:s,decimal:i}},O=new Map,b=(e={})=>{let{easing:t,numPoints:r}=w(e);if(!Array.isArray(t))throw new Error(`[spring-easing] The easing needs to be in the format:  \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity], the easing recieved is "${t}", [spring-easing] doesn't really know what to do with that.`);if("function"!=typeof t[0])throw new Error("[spring-easing] A frame function is required as the first element in the easing array, e.g. [SpringFrame, ...]");t.length>1&&t.length<5&&console.warn(`[spring-easing] Be careful of only setting some of the spring parameters, you've only set ${5-t.length} spring parameter(s). The easing works best in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`),t.length>5&&console.warn(`[spring-easing] You entered ${5-t.length} more spring parameter(s) than necessary. The easing needs to be in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`);let[n,...i]=t;const a=`${i},${r}`;if(O.has(a)){let e=O.get(a);if(e.has(n))return e.get(n)}const o=[];let p=s(i);for(let e=0;e<r;e++)o[e]=n(e/(r-1),i,p);let g=O.has(a)?O.get(a):new WeakMap;return g.set(n,[o,p]),O.set(a,g),[o,p]},v=(e,t={},r=F)=>{let n=w(t),[s,i]=b(n);return[s.map((t=>r(t,e,n.decimal))),i]};exports.EaseInOut=a,exports.EaseOut=i,exports.EaseOutIn=o,exports.EasingDurationCache=r,exports.EasingFunctions=M,exports.EasingOptions=w,exports.FramePtsCache=O,exports.GenerateSpringFrames=b,exports.INFINITE_LOOP_LIMIT=n,exports.SpringEasing=v,exports.SpringFrame=t,exports.SpringInFrame=p,exports.SpringInOutFrame=l,exports.SpringOutFrame=g,exports.SpringOutInFrame=u,exports.default=v,exports.getSpringDuration=s,exports.getUnit=y,exports.interpolateComplex=F,exports.interpolateNumber=h,exports.interpolateString=d,exports.interpolateUsingIndex=c,exports.isNumberLike=x,exports.limit=e,exports.parseEasingParameters=S,exports.scale=m,exports.toFixed=f;
