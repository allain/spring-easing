(function(i,l){typeof exports=="object"&&typeof module!="undefined"?l(exports):typeof define=="function"&&define.amd?define(["exports"],l):(i=typeof globalThis!="undefined"?globalThis:i||self,l(i.SpringEasing={}))})(this,function(i){"use strict";const l=(n,e,t)=>Math.min(Math.max(n,e),t),c=(n,[e=1,t=100,r=10,s=0]=[],a)=>{if(n===0||n===1)return n;e=l(e,.1,1e3),t=l(t,.1,1e3),r=l(r,.1,1e3),s=l(s,.1,1e3);const o=Math.sqrt(t/e),g=r/(2*Math.sqrt(t*e)),m=g<1?o*Math.sqrt(1-g*g):0,u=1,h=g<1?(g*o+-s)/m:-s+o;let p=a?a*n/1e3:n;return g<1?p=Math.exp(-p*g*o)*(u*Math.cos(m*p)+h*Math.sin(m*p)):p=(u+h*p)*Math.exp(-p*o),1-p},d=new Map,O=1e5,b=([n,e,t,r]=[])=>{let s=[n,e,t,r],a=`${s}`;if(d.has(a))return d.get(a);const o=1/6;let g=0,m=0,u=0;for(;++u<O;)if(g+=o,c(g,s,null)===1){if(m++,m>=16)break}else m=0;const h=g*o*1e3;return d.set(a,h),h},E=n=>(e,t=[],r)=>1-n(1-e,t,r),I=n=>(e,t=[],r)=>e<.5?n(e*2,t,r)/2:1-n(e*-2+2,t,r)/2,M=n=>(e,t=[],r)=>e<.5?(1-n(1-e*2,t,r))/2:(n(e*2-1,t,r)+1)/2,N=c,w=E(c),T=I(c),k=M(c),L=(n,e,t)=>e+(t-e)*n,P=(n,e)=>Math.round(n*10**e)/10**e,F=(n,e,t=3)=>{let r=e.length-1,s=l(Math.floor(n*r),0,r-1),a=e[s],o=e[s+1],g=(n-s/r)*r;return P(L(g,a,o),t)},S=n=>{let e=parseFloat(n);return typeof e=="number"&&!Number.isNaN(e)},C=(n,e)=>{n=l(n,0,1);let t=e.length-1,r=Math.round(n*t);return e[r]},_=n=>{let e=parseFloat(n);return n.toString().replace(e.toString(),"")},$=(n,e,t=3)=>{let r="";return S(e[0])&&(r=_(e[0])),F(n,e.map(s=>typeof s=="number"?s:parseFloat(s)),t)+r},j=(n,e,t=3)=>e.every(a=>typeof a=="number")?F(n,e,t):e.every(a=>S(a))?$(n,e,t):C(n,e),A={spring:c,"spring-in":N,"spring-out":w,"spring-in-out":T,"spring-out-in":k},q=n=>{const e=/(\(|\s)([^)]+)\)?/.exec(n.toString());return e?e[2].split(",").map(t=>{let r=parseFloat(t);return Number.isNaN(r)?t.trim():r}):[]},y=(n={})=>{let e=typeof n=="string"||Array.isArray(n)&&typeof n[0]=="function",{easing:t=[c,1,100,10,0],numPoints:r=100,decimal:s=3}=e?{easing:n}:n;if(typeof t=="string"){let a=A[t.replace(/(\(|\s).+/,"").toLowerCase().trim()],o=q(t);t=[a,...o]}return{easing:t,numPoints:r,decimal:s}},f=new Map,D=(n={})=>{let{easing:e,numPoints:t}=y(n);if(Array.isArray(e)){if(typeof e[0]!="function")throw new Error("[spring-easing] A frame function is required as the first element in the easing array, e.g. [SpringFrame, ...]");e.length>1&&e.length<5&&console.warn(`[spring-easing] Be careful of only setting some of the spring parameters, you've only set ${5-e.length} spring parameter(s). The easing works best in the format: 
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity].`),e.length>5&&console.warn(`[spring-easing] You entered ${5-e.length} more spring parameter(s) than necessary. The easing needs to be in the format: 
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity].`)}else throw new Error(`[spring-easing] The easing needs to be in the format:  
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity], the easing recieved is "${e}", [spring-easing] doesn't really know what to do with that.`);let[r,...s]=e;const a=`${s},${t}`;if(f.has(a)){let u=f.get(a);if(u.has(r))return u.get(r)}const o=[];let g=b(s);for(let u=0;u<t;u++)o[u]=r(u/(t-1),s,g);let m=f.has(a)?f.get(a):new WeakMap;return m.set(r,[o,g]),f.set(a,m),[o,g]},U=(n,e={},t=j)=>{let r=y(e),[s,a]=D(r);return[s.map(o=>t(o,n,r.decimal)),a]};i.EaseInOut=I,i.EaseOut=E,i.EaseOutIn=M,i.EasingDurationCache=d,i.EasingFunctions=A,i.EasingOptions=y,i.FramePtsCache=f,i.GenerateSpringFrames=D,i.INFINITE_LOOP_LIMIT=O,i.SpringEasing=U,i.SpringFrame=c,i.SpringInFrame=N,i.SpringInOutFrame=T,i.SpringOutFrame=w,i.SpringOutInFrame=k,i.default=U,i.getSpringDuration=b,i.getUnit=_,i.interpolateComplex=j,i.interpolateNumber=F,i.interpolateString=$,i.interpolateUsingIndex=C,i.isNumberLike=S,i.limit=l,i.parseEasingParameters=q,i.scale=L,i.toFixed=P,Object.defineProperties(i,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
