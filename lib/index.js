!function(e,t){"object"==typeof exports&&typeof module<"u"?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=typeof globalThis<"u"?globalThis:e||self).SpringEasing={})}(this,(function(e){"use strict";const t=(e,t,n)=>Math.min(Math.max(e,t),n),n=(e,[n=1,r=100,s=10,i=0]=[],a)=>{n=t(n,.1,1e3),r=t(r,.1,1e3),s=t(s,.1,1e3),i=t(i,.1,1e3);const o=Math.sqrt(r/n),g=s/(2*Math.sqrt(r*n)),p=g<1?o*Math.sqrt(1-g*g):0,l=g<1?(g*o-i)/p:-i+o;let u=a?a*e/1e3:e;return u=g<1?Math.exp(-u*g*o)*(1*Math.cos(p*u)+l*Math.sin(p*u)):(1+l*u)*Math.exp(-u*o),0===e||1===e?e:1-u},r=new Map,s=1e5,i=([e,t,i,a]=[])=>{let o=[e,t,i,a],g=`${o}`;if(r.has(g))return r.get(g);const p=1/6;let l=0,u=0,m=0;for(;++m<s;)if(l+=p,1===n(l,o,null)){if(u++,u>=16)break}else u=0;const f=l*p*1e3;return r.set(g,f),f},a=e=>(t,n=[],r)=>1-e(1-t,n,r),o=e=>(t,n=[],r)=>t<.5?e(2*t,n,r)/2:1-e(-2*t+2,n,r)/2,g=e=>(t,n=[],r)=>t<.5?(1-e(1-2*t,n,r))/2:(e(2*t-1,n,r)+1)/2,p=n,l=a(n),u=o(n),m=g(n),f=(e,t,n)=>t+(n-t)*e,h=(e,t)=>Math.round(e*10**t)/10**t,c=(e,n,r=3)=>{let s=n.length-1,i=t(Math.floor(e*s),0,s-1),a=n[i],o=n[i+1];return h(f((e-i/s)*s,a,o),r)},y=e=>{let t=parseFloat(e);return"number"==typeof t&&!Number.isNaN(t)},d=(e,n)=>{e=t(e,0,1);let r=n.length-1;return n[Math.round(e*r)]},F=e=>{let t=parseFloat(e);return e.toString().replace(t.toString(),"")},M=(e,t,n=3)=>{let r="";return y(t[0])&&(r=F(t[0])),c(e,t.map((e=>"number"==typeof e?e:parseFloat(e))),n)+r},S=(e,t,n=3)=>t.every((e=>"number"==typeof e))?c(e,t,n):t.every((e=>y(e)))?M(e,t,n):d(e,t),b={spring:n,"spring-in":p,"spring-out":l,"spring-in-out":u,"spring-out-in":m},w=e=>{const t=/(\(|\s)([^)]+)\)?/.exec(e.toString());return t?t[2].split(",").map((e=>{let t=parseFloat(e);return Number.isNaN(t)?e.trim():t})):[]},O=(e={})=>{let t="string"==typeof e||Array.isArray(e)&&"function"==typeof e[0],{easing:r=[n,1,100,10,0],numPoints:s=100,decimal:i=3}=t?{easing:e}:e;if("string"==typeof r){let e=b[r.replace(/(\(|\s).+/,"").toLowerCase().trim()];r=[e,...w(r)]}return{easing:r,numPoints:s,decimal:i}},E=new Map,v=(e={})=>{let{easing:t,numPoints:n}=O(e);if(!Array.isArray(t))throw new Error(`[spring-easing] The easing needs to be in the format:  \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity], the easing recieved is "${t}", [spring-easing] doesn't really know what to do with that.`);if("function"!=typeof t[0])throw new Error("[spring-easing] A frame function is required as the first element in the easing array, e.g. [SpringFrame, ...]");t.length>1&&t.length<5&&console.warn(`[spring-easing] Be careful of only setting some of the spring parameters, you've only set ${5-t.length} spring parameter(s). The easing works best in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`),t.length>5&&console.warn(`[spring-easing] You entered ${5-t.length} more spring parameter(s) than necessary. The easing needs to be in the format: \n* "spring-out(mass, stiffness, damping, velocity)" or \n* [SpringOutFrame, mass, stiffness, damping, velocity].`);let[r,...s]=t;const a=`${s},${n}`;if(E.has(a)){let e=E.get(a);if(e.has(r))return e.get(r)}const o=[];let g=i(s);for(let e=0;e<n;e++)o[e]=r(e/(n-1),s,g);let p=E.has(a)?E.get(a):new WeakMap;return p.set(r,[o,g]),E.set(a,p),[o,g]},I=(e,t={},n=S)=>{let r=O(t),[s,i]=v(r);return[s.map((t=>n(t,e,r.decimal))),i]};e.EaseInOut=o,e.EaseOut=a,e.EaseOutIn=g,e.EasingDurationCache=r,e.EasingFunctions=b,e.EasingOptions=O,e.FramePtsCache=E,e.GenerateSpringFrames=v,e.INTINITE_LOOP_LIMIT=s,e.SpringEasing=I,e.SpringFrame=n,e.SpringInFrame=p,e.SpringInOutFrame=u,e.SpringOutFrame=l,e.SpringOutInFrame=m,e.default=I,e.getSpringDuration=i,e.getUnit=F,e.interpolateComplex=S,e.interpolateNumber=c,e.interpolateString=M,e.interpolateUsingIndex=d,e.isNumberLike=y,e.limit=t,e.parseEasingParameters=w,e.scale=f,e.toFixed=h,Object.defineProperty(e,"__esModule",{value:!0})}));
